To Do
	signalr
		on login/register create connection
			connection name is user id
			get all chatrooms for user
				foreach chatroom
					if group named after chatroom id exists
						add connection to group
					else
						create group
						add connection to group
		when creating a chatroom 
			create chatroom
				add chatroom and members to db
			create group named after chatroom id
			add current user to group
			if connections named after other members' ids exist
				add those connections to group
		when joining a chatroom
			create new AppUserChatroom and add to db
			if group exists
				add connection to group
			else
				create group and add connection to group
		when sending a message
			add message to db
			send message to all connections in group	
		when user leaves chatroom
			remove AppUserChatroom
			remove connection from group
		when deleting a chatroom
			delete group
			deleter chatroom and all messages (test for cascade delete)
		when deleting account
			delete AppUser
			delete messages (test for cascade delete)
			delete AppUserChatroom (test for cascade delete)
			
			
		
		
	Reference C# code
		
		using Microsoft.AspNetCore.SignalR;
		using System.Threading.Tasks;

		namespace SignalRChat.Hubs
		{
			public class ChatHub : Hub
			{
				public async Task SendMessage(string user, string message)
				{
					await Clients.All.SendAsync("ReceiveMessage", user, message);
				}
			}
		}
		
	put these in startup.cs
		services.AddSignalR();
		endpoints.MapHub<ChatHub>("/chatHub");
		
	Reference JS code
		"use strict";

		var connection = new signalR.HubConnectionBuilder().withUrl("/chatHub").build();

		//Disable send button until connection is established
		document.getElementById("sendButton").disabled = true;

		connection.on("ReceiveMessage", function (user, message) {
			console.log("message recieved!!!!!!!");
			var li = document.createElement("li");
			document.getElementById("messagesList").appendChild(li);
			// We can assign user-supplied strings to an element's textContent because it
			// is not interpreted as markup. If you're assigning in any other way, you 
			// should be aware of possible script injection concerns.
			li.textContent = `${user} says ${message}`;
		});

		connection.start().then(function () {
			console.log("connection started!!!!!!!");
			document.getElementById("sendButton").disabled = false;
		}).catch(function (err) {
			return console.error(err.toString());
		});

		document.getElementById("sendButton").addEventListener("click", function (event) {
			var user = document.getElementById("userInput").value;
			var message = document.getElementById("messageInput").value;
			connection.invoke("SendMessage", user, message).then(function () {
				console.log("connection invoked");
			}).catch (function (err) {
				return console.error(err.toString());
			});
			event.preventDefault();
		});